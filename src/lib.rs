use std::cmp::max;

// ビット番号からi座標を返す
#[no_mangle]
pub extern "C" fn index_to_position_i(n: i32) -> i32 {
    n & 0x07
}

// ビット番号からj座標を返す
#[no_mangle]
pub extern "C" fn index_to_position_j(n: i32) -> i32 {
    n >> 3
}

// 座標位置からビット番号を返す
#[no_mangle]
pub extern "C" fn position_to_index(i: i32, j: i32) -> i32 {
    (j << 3) | i
}

// n番目にだけビットを立たせたビットボード表現を返す
#[no_mangle]
pub extern "C" fn index_to_bit(n: i32) -> u64 {
    0x01u64 << n
}

// 特定の座標位置に対応する場所にだけビットを立たせたビットボード表現を返す
#[no_mangle]
pub extern "C" fn position_to_bit(i: i32, j: i32) -> u64 {
    index_to_bit(position_to_index(i, j))
}

// 空いているマスのビットボード表現を返す
#[no_mangle]
pub extern "C" fn empty_squares(player1: u64, player2: u64) -> u64 {
    !(player1 | player2)
}

// myselfプレイヤーが着手可能な手のビットボード表現を返す
#[no_mangle]
pub extern "C" fn possible_moves(myself: u64, opponent: u64) -> u64 {
    let blank = empty_squares(myself, opponent);
    let opp = opponent & 0x7E7E7E7E7E7E7E7E;
    let mut moves = 0;
    let mut flip: u64;
    // 北
    flip = opponent & (myself << 8);
    flip |= opponent & (flip << 8);
    flip |= opponent & (flip << 8);
    flip |= opponent & (flip << 8);
    flip |= opponent & (flip << 8);
    flip |= opponent & (flip << 8);
    moves = flip << 8;
    // 北東
    flip = opp & (myself << 7);
    flip |= opp & (flip << 7);
    flip |= opp & (flip << 7);
    flip |= opp & (flip << 7);
    flip |= opp & (flip << 7);
    flip |= opp & (flip << 7);
    moves |= flip << 7;
    // 東
    flip = opp & (myself >> 1);
    flip |= opp & (flip >> 1);
    flip |= opp & (flip >> 1);
    flip |= opp & (flip >> 1);
    flip |= opp & (flip >> 1);
    flip |= opp & (flip >> 1);
    moves |= flip >> 1;
    // 南東
    flip = opp & (myself >> 9);
    flip |= opp & (flip >> 9);
    flip |= opp & (flip >> 9);
    flip |= opp & (flip >> 9);
    flip |= opp & (flip >> 9);
    flip |= opp & (flip >> 9);
    moves |= flip >> 9;
    // 南
    flip = opponent & (myself >> 8);
    flip |= opponent & (flip >> 8);
    flip |= opponent & (flip >> 8);
    flip |= opponent & (flip >> 8);
    flip |= opponent & (flip >> 8);
    flip |= opponent & (flip >> 8);
    moves |= flip >> 8;
    // 南西
    flip = opp & (myself >> 7);
    flip |= opp & (flip >> 7);
    flip |= opp & (flip >> 7);
    flip |= opp & (flip >> 7);
    flip |= opp & (flip >> 7);
    flip |= opp & (flip >> 7);
    moves |= flip >> 7;
    // 西
    flip = opp & (myself << 1);
    flip |= opp & (flip << 1);
    flip |= opp & (flip << 1);
    flip |= opp & (flip << 1);
    flip |= opp & (flip << 1);
    flip |= opp & (flip << 1);
    moves |= flip << 1;
    // 北西
    flip = opp & (myself << 9);
    flip |= opp & (flip << 9);
    flip |= opp & (flip << 9);
    flip |= opp & (flip << 9);
    flip |= opp & (flip << 9);
    flip |= opp & (flip << 9);
    moves |= flip << 9;
    moves & blank
}

// myselfプレイヤーがindex地点に打ったときに返せる石のビットボード表現を返す
#[no_mangle]
pub extern "C" fn turnovers(myself: u64, opponent: u64, index: i32) -> u64 {
    let mut turns = 0x00;
    let pos = index_to_bit(index);
    let opp = opponent & 0x7E7E7E7E7E7E7E7E;
    let mut t: u64;
    // 北
    t = (pos << 8) & opponent;
    t |= (t << 8) & opponent;
    t |= (t << 8) & opponent;
    t |= (t << 8) & opponent;
    t |= (t << 8) & opponent;
    t |= (t << 8) & opponent;
    if (t << 8) & myself != 0 {
        turns |= t;
    }
    // 北東
    t = (pos << 7) & opp;
    t |= (t << 7) & opp;
    t |= (t << 7) & opp;
    t |= (t << 7) & opp;
    t |= (t << 7) & opp;
    t |= (t << 7) & opp;
    if (t << 7) & myself != 0 {
        turns |= t;
    }
    // 東
    t = (pos >> 1) & opp;
    t |= (t >> 1) & opp;
    t |= (t >> 1) & opp;
    t |= (t >> 1) & opp;
    t |= (t >> 1) & opp;
    t |= (t >> 1) & opp;
    if (t >> 1) & myself != 0 {
        turns |= t;
    }
    // 南東
    t = (pos >> 9) & opp;
    t |= (t >> 9) & opp;
    t |= (t >> 9) & opp;
    t |= (t >> 9) & opp;
    t |= (t >> 9) & opp;
    t |= (t >> 9) & opp;
    if (t >> 9) & myself != 0 {
        turns |= t;
    }
    // 南
    t = (pos >> 8) & opponent;
    t |= (t >> 8) & opponent;
    t |= (t >> 8) & opponent;
    t |= (t >> 8) & opponent;
    t |= (t >> 8) & opponent;
    t |= (t >> 8) & opponent;
    if (t >> 8) & myself != 0 {
        turns |= t;
    }
    // 南西
    t = (pos >> 7) & opp;
    t |= (t >> 7) & opp;
    t |= (t >> 7) & opp;
    t |= (t >> 7) & opp;
    t |= (t >> 7) & opp;
    t |= (t >> 7) & opp;
    if (t >> 7) & myself != 0 {
        turns |= t;
    }
    // 西
    t = (pos << 1) & opp;
    t |= (t << 1) & opp;
    t |= (t << 1) & opp;
    t |= (t << 1) & opp;
    t |= (t << 1) & opp;
    t |= (t << 1) & opp;
    if (t << 1) & myself != 0 {
        turns |= t;
    }
    // 北西
    t = (pos << 9) & opp;
    t |= (t << 9) & opp;
    t |= (t << 9) & opp;
    t |= (t << 9) & opp;
    t |= (t << 9) & opp;
    t |= (t << 9) & opp;
    if (t << 9) & myself != 0 {
        turns |= t;
    }
    turns
}

// myselfプレイヤーがindex地点に打てるかどうかを返す
#[no_mangle]
pub extern "C" fn can_place(myself: u64, opponent: u64, index: i32) -> i32 {
    1 & (possible_moves(myself, opponent) & index_to_bit(index) != 0) as i32
}

// myselfプレイヤーがindex地点に打ったときに得られる盤を間接参照によって代入し、返した石のビットボード表現を返す
#[no_mangle]
pub extern "C" fn place(
    myself: u64,
    opponent: u64,
    index: i32,
    nmyself: &mut u64,
    nopponent: &mut u64,
) -> u64 {
    let turns = turnovers(myself, opponent, index);
    *nmyself = myself | turns | index_to_bit(index);
    *nopponent = opponent & !turns;
    turns
}

// 立っているビットの数を返す
#[no_mangle]
pub extern "C" fn count_bits(n: u64) -> i32 {
    let mut n = n;
    n = ((n & 0xAAAA_AAAA_AAAA_AAAA) >> 1) + (n & 0x5555_5555_5555_5555);
    n = ((n & 0xCCCC_CCCC_CCCC_CCCC) >> 2) + (n & 0x3333_3333_3333_3333);
    n = ((n & 0xF0F0_F0F0_F0F0_F0F0) >> 4) + (n & 0x0F0F_0F0F_0F0F_0F0F);
    n = ((n & 0xFF00_FF00_FF00_FF00) >> 8) + (n & 0x00FF_00FF_00FF_00FF);
    n = ((n & 0xFFFF_0000_FFFF_0000) >> 16) + (n & 0x0000_FFFF_0000_FFFF);
    n = ((n & 0xFFFF_FFFF_0000_0000) >> 32) + (n & 0x0000_0000_FFFF_FFFF);
    n as i32
}

// myselfプレイヤーの石の数からopponentプレイヤーの石の数を引いたものを返す
#[no_mangle]
pub extern "C" fn balance(myself: u64, opponent: u64) -> i32 {
    count_bits(myself) - count_bits(opponent)
}

// 有利なほど大きいように盤上の位置ごとにつけられた重みを用いて、石のある位置の重みの和を返す
#[no_mangle]
pub extern "C" fn sum_of_weights(disks: u64) -> i32 {
    const W1: [i32; 256] = [ 0, 10000, -3000, 7000, 1000, 11000, -2000, 8000, 800, 10800, -2200, 7800, 1800, 11800, -1200, 8800, 800, 10800, -2200, 7800, 1800, 11800, -1200, 8800, 1600, 11600, -1400, 8600, 2600, 12600, -400, 9600, 1000, 11000, -2000, 8000, 2000, 12000, -1000, 9000, 1800, 11800, -1200, 8800, 2800, 12800, -200, 9800, 1800, 11800, -1200, 8800, 2800, 12800, -200, 9800, 2600, 12600, -400, 9600, 3600, 13600, 600, 10600, -3000, 7000, -6000, 4000, -2000, 8000, -5000, 5000, -2200, 7800, -5200, 4800, -1200, 8800, -4200, 5800, -2200, 7800, -5200, 4800, -1200, 8800, -4200, 5800, -1400, 8600, -4400, 5600, -400, 9600, -3400, 6600, -2000, 8000, -5000, 5000, -1000, 9000, -4000, 6000, -1200, 8800, -4200, 5800, -200, 9800, -3200, 6800, -1200, 8800, -4200, 5800, -200, 9800, -3200, 6800, -400, 9600, -3400, 6600, 600, 10600, -2400, 7600, 10000, 20000, 7000, 17000, 11000, 21000, 8000, 18000, 10800, 20800, 7800, 17800, 11800, 21800, 8800, 18800, 10800, 20800, 7800, 17800, 11800, 21800, 8800, 18800, 11600, 21600, 8600, 18600, 12600, 22600, 9600, 19600, 11000, 21000, 8000, 18000, 12000, 22000, 9000, 19000, 11800, 21800, 8800, 18800, 12800, 22800, 9800, 19800, 11800, 21800, 8800, 18800, 12800, 22800, 9800, 19800, 12600, 22600, 9600, 19600, 13600, 23600, 10600, 20600, 7000, 17000, 4000, 14000, 8000, 18000, 5000, 15000, 7800, 17800, 4800, 14800, 8800, 18800, 5800, 15800, 7800, 17800, 4800, 14800, 8800, 18800, 5800, 15800, 8600, 18600, 5600, 15600, 9600, 19600, 6600, 16600, 8000, 18000, 5000, 15000, 9000, 19000, 6000, 16000, 8800, 18800, 5800, 15800, 9800, 19800, 6800, 16800, 8800, 18800, 5800, 15800, 9800, 19800, 6800, 16800, 9600, 19600, 6600, 16600, 10600, 20600, 7600, 17600 ];
    const W2: [i32; 256] = [ 0, -3000, -5000, -8000, -450, -3450, -5450, -8450, -500, -3500, -5500, -8500, -950, -3950, -5950, -8950, -500, -3500, -5500, -8500, -950, -3950, -5950, -8950, -1000, -4000, -6000, -9000, -1450, -4450, -6450, -9450, -450, -3450, -5450, -8450, -900, -3900, -5900, -8900, -950, -3950, -5950, -8950, -1400, -4400, -6400, -9400, -950, -3950, -5950, -8950, -1400, -4400, -6400, -9400, -1450, -4450, -6450, -9450, -1900, -4900, -6900, -9900, -5000, -8000, -10000, -13000, -5450, -8450, -10450, -13450, -5500, -8500, -10500, -13500, -5950, -8950, -10950, -13950, -5500, -8500, -10500, -13500, -5950, -8950, -10950, -13950, -6000, -9000, -11000, -14000, -6450, -9450, -11450, -14450, -5450, -8450, -10450, -13450, -5900, -8900, -10900, -13900, -5950, -8950, -10950, -13950, -6400, -9400, -11400, -14400, -5950, -8950, -10950, -13950, -6400, -9400, -11400, -14400, -6450, -9450, -11450, -14450, -6900, -9900, -11900, -14900, -3000, -6000, -8000, -11000, -3450, -6450, -8450, -11450, -3500, -6500, -8500, -11500, -3950, -6950, -8950, -11950, -3500, -6500, -8500, -11500, -3950, -6950, -8950, -11950, -4000, -7000, -9000, -12000, -4450, -7450, -9450, -12450, -3450, -6450, -8450, -11450, -3900, -6900, -8900, -11900, -3950, -6950, -8950, -11950, -4400, -7400, -9400, -12400, -3950, -6950, -8950, -11950, -4400, -7400, -9400, -12400, -4450, -7450, -9450, -12450, -4900, -7900, -9900, -12900, -8000, -11000, -13000, -16000, -8450, -11450, -13450, -16450, -8500, -11500, -13500, -16500, -8950, -11950, -13950, -16950, -8500, -11500, -13500, -16500, -8950, -11950, -13950, -16950, -9000, -12000, -14000, -17000, -9450, -12450, -14450, -17450, -8450, -11450, -13450, -16450, -8900, -11900, -13900, -16900, -8950, -11950, -13950, -16950, -9400, -12400, -14400, -17400, -8950, -11950, -13950, -16950, -9400, -12400, -14400, -17400, -9450, -12450, -14450, -17450, -9900, -12900, -14900, -17900 ];
    const W3: [i32; 256] = [ 0, 1000, -450, 550, 30, 1030, -420, 580, 10, 1010, -440, 560, 40, 1040, -410, 590, 10, 1010, -440, 560, 40, 1040, -410, 590, 20, 1020, -430, 570, 50, 1050, -400, 600, 30, 1030, -420, 580, 60, 1060, -390, 610, 40, 1040, -410, 590, 70, 1070, -380, 620, 40, 1040, -410, 590, 70, 1070, -380, 620, 50, 1050, -400, 600, 80, 1080, -370, 630, -450, 550, -900, 100, -420, 580, -870, 130, -440, 560, -890, 110, -410, 590, -860, 140, -440, 560, -890, 110, -410, 590, -860, 140, -430, 570, -880, 120, -400, 600, -850, 150, -420, 580, -870, 130, -390, 610, -840, 160, -410, 590, -860, 140, -380, 620, -830, 170, -410, 590, -860, 140, -380, 620, -830, 170, -400, 600, -850, 150, -370, 630, -820, 180, 1000, 2000, 550, 1550, 1030, 2030, 580, 1580, 1010, 2010, 560, 1560, 1040, 2040, 590, 1590, 1010, 2010, 560, 1560, 1040, 2040, 590, 1590, 1020, 2020, 570, 1570, 1050, 2050, 600, 1600, 1030, 2030, 580, 1580, 1060, 2060, 610, 1610, 1040, 2040, 590, 1590, 1070, 2070, 620, 1620, 1040, 2040, 590, 1590, 1070, 2070, 620, 1620, 1050, 2050, 600, 1600, 1080, 2080, 630, 1630, 550, 1550, 100, 1100, 580, 1580, 130, 1130, 560, 1560, 110, 1110, 590, 1590, 140, 1140, 560, 1560, 110, 1110, 590, 1590, 140, 1140, 570, 1570, 120, 1120, 600, 1600, 150, 1150, 580, 1580, 130, 1130, 610, 1610, 160, 1160, 590, 1590, 140, 1140, 620, 1620, 170, 1170, 590, 1590, 140, 1140, 620, 1620, 170, 1170, 600, 1600, 150, 1150, 630, 1630, 180, 1180 ];
    const W4: [i32; 256] = [ 0, 800, -500, 300, 10, 810, -490, 310, 50, 850, -450, 350, 60, 860, -440, 360, 50, 850, -450, 350, 60, 860, -440, 360, 100, 900, -400, 400, 110, 910, -390, 410, 10, 810, -490, 310, 20, 820, -480, 320, 60, 860, -440, 360, 70, 870, -430, 370, 60, 860, -440, 360, 70, 870, -430, 370, 110, 910, -390, 410, 120, 920, -380, 420, -500, 300, -1000, -200, -490, 310, -990, -190, -450, 350, -950, -150, -440, 360, -940, -140, -450, 350, -950, -150, -440, 360, -940, -140, -400, 400, -900, -100, -390, 410, -890, -90, -490, 310, -990, -190, -480, 320, -980, -180, -440, 360, -940, -140, -430, 370, -930, -130, -440, 360, -940, -140, -430, 370, -930, -130, -390, 410, -890, -90, -380, 420, -880, -80, 800, 1600, 300, 1100, 810, 1610, 310, 1110, 850, 1650, 350, 1150, 860, 1660, 360, 1160, 850, 1650, 350, 1150, 860, 1660, 360, 1160, 900, 1700, 400, 1200, 910, 1710, 410, 1210, 810, 1610, 310, 1110, 820, 1620, 320, 1120, 860, 1660, 360, 1160, 870, 1670, 370, 1170, 860, 1660, 360, 1160, 870, 1670, 370, 1170, 910, 1710, 410, 1210, 920, 1720, 420, 1220, 300, 1100, -200, 600, 310, 1110, -190, 610, 350, 1150, -150, 650, 360, 1160, -140, 660, 350, 1150, -150, 650, 360, 1160, -140, 660, 400, 1200, -100, 700, 410, 1210, -90, 710, 310, 1110, -190, 610, 320, 1120, -180, 620, 360, 1160, -140, 660, 370, 1170, -130, 670, 360, 1160, -140, 660, 370, 1170, -130, 670, 410, 1210, -90, 710, 420, 1220, -80, 720 ];

    let w = W1[(disks & 0xFF) as usize]
        + W2[((disks >> 8) & 0xFF) as usize]
        + W3[((disks >> 16) & 0xFF) as usize]
        + W4[((disks >> 24) & 0xFF) as usize]
        + W4[((disks >> 32) & 0xFF) as usize]
        + W3[((disks >> 40) & 0xFF) as usize]
        + W2[((disks >> 48) & 0xFF) as usize]
        + W1[(disks >> 56) as usize];

    w
}

// myselfプレイヤーに有利なほど大きな数が返る静的評価関数
#[no_mangle]
pub extern "C" fn evaluation(myself: u64, opponent: u64) -> i32 {
    let b = count_bits(myself | opponent);
    let k = 50 * b;
    (sum_of_weights(myself) - sum_of_weights(opponent)) + k * (count_bits(possible_moves(myself, opponent)) - count_bits(possible_moves(opponent, myself)))
}

// turns周りの開放度を返す
#[no_mangle]
pub extern "C" fn openness(myself: u64, opponent: u64, turns: u64) -> i32 {
    let blank = empty_squares(myself, opponent);
    let blae = blank & 0x7F7F_7F7F_7F7F_7F7F;
    let blaw = blank & 0xFEFE_FEFE_FEFE_FEFE;
    let mut o = 0;
    o += count_bits((turns << 8) & blank);
    o += count_bits((turns << 7) & blae);
    o += count_bits((turns >> 1) & blae);
    o += count_bits((turns >> 9) & blae);
    o += count_bits((turns >> 8) & blank);
    o += count_bits((turns >> 7) & blaw);
    o += count_bits((turns << 1) & blaw);
    o += count_bits((turns << 9) & blaw);
    o
}

// 係数を掛けた開放度の負値を返す
#[no_mangle]
pub extern "C" fn openness_evaluation(myself: u64, opponent: u64, turns: u64) -> i32 {
    // 開放度に掛ける適当な係数
    const K: i32 = 10;
    -K * openness(myself, opponent, turns)
}

